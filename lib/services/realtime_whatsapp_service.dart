import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:geolocator/geolocator.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:async';
import 'native_location_sharing.dart';

class RealtimeWhatsAppService {
  static Timer? _locationTimer;
  static bool _isSharingLocation = false;
  static const String _isSharingKey = 'is_sharing_location';
  static const String _sharingDurationKey = 'sharing_duration';

  // Iniciar compartir ubicaci√≥n en tiempo real
  static Future<void> startRealtimeLocationSharing({
    required String threatDescription,
    required String additionalText,
    required List<String> phoneNumbers,
    int durationMinutes = 60, // Duraci√≥n por defecto: 1 hora
  }) async {
    if (_isSharingLocation) {
      debugPrint('Ya se est√° compartiendo ubicaci√≥n en tiempo real');
      return;
    }

    _isSharingLocation = true;
    await _saveSharingStatus(true, durationMinutes);

    debugPrint('üöÄ Iniciando compartir ubicaci√≥n en tiempo real por WhatsApp');

    // Intentar usar el servicio nativo primero
    debugPrint(
      'üöÄ Intentando usar servicio nativo para ubicaci√≥n en tiempo real',
    );
    final nativeSuccess = await NativeLocationSharing.shareLiveLocation(
      phoneNumbers: phoneNumbers,
      threatDescription: threatDescription,
      durationMinutes: durationMinutes,
    );

    if (nativeSuccess) {
      debugPrint('‚úÖ Servicio nativo activado exitosamente');
      return;
    }

    // Fallback: usar m√©todo tradicional
    debugPrint('üì± Usando m√©todo tradicional de WhatsApp');
    // Enviar mensaje inicial
    await _sendInitialLocationMessage(
      threatDescription: threatDescription,
      additionalText: additionalText,
      phoneNumbers: phoneNumbers,
    );

    // Iniciar timer para enviar ubicaci√≥n cada 30 segundos
    _locationTimer = Timer.periodic(const Duration(seconds: 30), (timer) async {
      await _sendLocationUpdate(
        phoneNumbers,
        threatDescription: threatDescription,
        additionalText: additionalText,
      );
    });

    // Programar parada autom√°tica
    Timer(Duration(minutes: durationMinutes), () {
      stopRealtimeLocationSharing();
    });
  }

  // Detener compartir ubicaci√≥n en tiempo real
  static Future<void> stopRealtimeLocationSharing() async {
    if (!_isSharingLocation) return;

    _isSharingLocation = false;
    _locationTimer?.cancel();
    _locationTimer = null;

    await _saveSharingStatus(false, 0);

    // Detener servicio nativo si est√° activo
    await NativeLocationSharing.stopLiveLocationSharing();

    debugPrint('üõë Deteniendo compartir ubicaci√≥n en tiempo real');
  }

  // Verificar si se est√° compartiendo ubicaci√≥n
  static Future<bool> isSharingLocation() async {
    final prefs = await SharedPreferences.getInstance();
    final localSharing = prefs.getBool(_isSharingKey) ?? false;

    // Tambi√©n verificar el servicio nativo
    final nativeSharing = await NativeLocationSharing.isSharingLocation();

    return localSharing || nativeSharing;
  }

  // Enviar mensaje inicial con ubicaci√≥n
  static Future<void> _sendInitialLocationMessage({
    required String threatDescription,
    required String additionalText,
    required List<String> phoneNumbers,
  }) async {
    try {
      final position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.bestForNavigation,
        timeLimit: const Duration(seconds: 10),
      );

      final location = '${position.latitude}, ${position.longitude}';
      final googleMapsUrl =
          'https://maps.google.com/?q=${position.latitude},${position.longitude}';

      final message = '''üö® *ALERTA SOS ACTIVA* üö®

*Descripci√≥n:* $threatDescription${additionalText.isNotEmpty ? ' - $additionalText' : ''}

üìç *Mi ubicaci√≥n actual:* $location
üîó *Ver en Google Maps:* $googleMapsUrl

üåê *VER UBICACI√ìN EN TIEMPO REAL:*
https://s-o-s-prevencion-segura.onrender.com/

‚è∞ *Hora:* ${DateTime.now().toString()}

üîÑ *UBICACI√ìN EN TIEMPO REAL ACTIVADA*
‚Ä¢ Se compartir√° mi ubicaci√≥n cada 30 segundos
‚Ä¢ Duraci√≥n: 60 minutos
‚Ä¢ La ubicaci√≥n se actualiza autom√°ticamente
‚Ä¢ Haz clic en el enlace arriba para ver mi ubicaci√≥n en vivo

*Esta alerta fue enviada autom√°ticamente por la app Prevenci√≥n Segura*''';

      // Enviar a todos los n√∫meros
      for (final phoneNumber in phoneNumbers) {
        await _sendWhatsAppMessage(phoneNumber, message);
        await Future.delayed(const Duration(milliseconds: 500));
      }
    } catch (e) {
      debugPrint('Error enviando mensaje inicial: $e');
    }
  }

  // Enviar actualizaci√≥n de ubicaci√≥n
  static Future<void> _sendLocationUpdate(
    List<String> phoneNumbers, {
    String threatDescription = '',
    String additionalText = '',
  }) async {
    try {
      final position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.bestForNavigation,
        timeLimit: const Duration(seconds: 10),
      );

      final location = '${position.latitude}, ${position.longitude}';
      final googleMapsUrl =
          'https://maps.google.com/?q=${position.latitude},${position.longitude}';

      final message = '''üìç *ACTUALIZACI√ìN DE UBICACI√ìN EN TIEMPO REAL*

*Descripci√≥n de la amenaza:* $threatDescription${additionalText.isNotEmpty ? ' - $additionalText' : ''}

*Ubicaci√≥n actual:* $location
*Precisi√≥n:* ${position.accuracy.toStringAsFixed(1)}m
*Hora:* ${DateTime.now().toString()}

üîó *Ver en Google Maps:* $googleMapsUrl

üåê *VER UBICACI√ìN EN TIEMPO REAL:*
https://s-o-s-prevencion-segura.onrender.com/

üîÑ *UBICACI√ìN EN TIEMPO REAL ACTIVA*
‚Ä¢ Se actualiza autom√°ticamente cada 30 segundos
‚Ä¢ Duraci√≥n: 60 minutos
‚Ä¢ La ubicaci√≥n se comparte en tiempo real
‚Ä¢ Haz clic en el enlace arriba para ver mi ubicaci√≥n en vivo

*Ubicaci√≥n en tiempo real - Prevenci√≥n Segura*''';

      // Usar m√©todo tradicional de WhatsApp
      debugPrint('üì± Enviando ubicaci√≥n por WhatsApp');
      // Enviar a todos los n√∫meros
      for (final phoneNumber in phoneNumbers) {
        await _sendWhatsAppMessage(phoneNumber, message);
        await Future.delayed(const Duration(milliseconds: 300));
      }

      debugPrint('üìç Ubicaci√≥n actualizada enviada: $location');
    } catch (e) {
      debugPrint('Error enviando actualizaci√≥n de ubicaci√≥n: $e');
    }
  }

  // Enviar mensaje por WhatsApp
  static Future<void> _sendWhatsAppMessage(
    String phoneNumber,
    String message,
  ) async {
    try {
      final encodedMessage = Uri.encodeComponent(message);
      final whatsappUrl = 'https://wa.me/$phoneNumber?text=$encodedMessage';
      final uri = Uri.parse(whatsappUrl);

      if (await canLaunchUrl(uri)) {
        await launchUrl(uri, mode: LaunchMode.externalApplication);
      }
    } catch (e) {
      debugPrint('Error enviando mensaje a $phoneNumber: $e');
    }
  }

  // Guardar estado de compartir ubicaci√≥n
  static Future<void> _saveSharingStatus(bool isSharing, int duration) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool(_isSharingKey, isSharing);
      await prefs.setInt(_sharingDurationKey, duration);
    } catch (e) {
      debugPrint('Error guardando estado de compartir ubicaci√≥n: $e');
    }
  }

  // Obtener contactos de emergencia
  static Future<List<String>> getEmergencyContacts() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final contactsJson = prefs.getString('emergency_contacts');

      if (contactsJson != null) {
        final List<dynamic> contacts =
            (prefs.getString('emergency_contacts') ?? '[]').split(',');
        return contacts
            .where((contact) => contact.toString().isNotEmpty)
            .cast<String>()
            .toList();
      }
    } catch (e) {
      debugPrint('Error obteniendo contactos de emergencia: $e');
    }

    return [];
  }

  // Inicializar servicio
  static Future<void> initialize() async {
    final isSharing = await isSharingLocation();
    if (isSharing) {
      // Si se estaba compartiendo antes de cerrar la app, reanudar
      final contacts = await getEmergencyContacts();
      if (contacts.isNotEmpty) {
        await startRealtimeLocationSharing(
          threatDescription: 'Reanudando alerta SOS',
          additionalText: 'La app se reinici√≥',
          phoneNumbers: contacts,
        );
      }
    }
  }
}
